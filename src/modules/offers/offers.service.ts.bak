import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { Prisma } from '@prisma/client';
import { API_RESPONSE_MESSAGES } from '../../constants/api-response/api-response.constants';
import { CreateOfferDto } from './dto/create-offer.dto';
import { UpdateOfferDto } from './dto/update-offer.dto';
import { AssignBranchesDto } from './dto/assign-branches.dto';
import { ApproveRejectOfferDto } from './dto/approve-reject-offer.dto';
import { ROLES, OfferStatus, DISCOUNT_TYPE } from '../../constants/app.constants';
import { CurrentUser } from '../../types/global.types';
import {
  calculatePaginationMeta,
  calculateSkip,
  PaginationMeta,
} from '../../utils/pagination.util';
import { SetFeaturedOffersDto } from './dto/set-featured-offers.dto';
import { Logger } from '@nestjs/common';

export interface OfferResponse {
  id: string;
  merchantId: string;
  title: string;
  description: string | null;
  imageUrl: string | null;
  discountType: string;
  discountValue: number;
  minOrderValue: number | null;
  maxDiscountAmount: number | null;
  termsConditions: string | null;
  validFrom: Date;
  validUntil: Date;
  dailyLimit: number | null;
  totalLimit: number | null;
  currentRedemptions: number;
  status: string;
  createdBy: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
  scheduleType: string | null;
  allowedDays: number[];
  startTime: string | null;
  endTime: string | null;
  branches?: Array<{
    branchId: string;
    branchName: string;
    isActive: boolean;
  }>;
  merchant?: {
    id: string;
    businessName: string;
    logoPath: string | null;
    category: string | null;
    bannerUrl: string | null;
  };
  featuredOrder?: number | null;
  additionalItem?: string | null;
  notes?: string | null;
}

export interface OfferAnalyticsResponse {
  totalRedemptions: number;
  currentRedemptions: number;
  remainingRedemptions: number | null;
  redemptionsByBranch: Array<{
    branchId: string;
    branchName: string;
    redemptionCount: number;
  }>;
  redemptionsByDate: Array<{
    date: string;
    count: number;
  }>;
}

export interface OfferResponseWithDistance extends OfferResponse {
  distance?: number;
}

export interface OfferDetailsResponse extends OfferResponse {
  branches: Array<{
    branchId: string;
    branchName: string;
    address: string;
    city: string;
    latitude: number | null;
    longitude: number | null;
    distance?: number;
    isActive: boolean;
  }>;
}

@Injectable()
export class OffersService {
  constructor(private readonly prisma: PrismaService) { }
  private readonly logger = new Logger(OffersService.name);

  /**
   * Create a new offer
   * Merchant Corporate or Admin
   */
  async createOffer(
    createDto: CreateOfferDto,
    currentUser: CurrentUser,
  ): Promise<OfferResponse> {
    this.logger.log(`Creating offer: ${JSON.stringify(createDto)} for user: ${currentUser.id}`);
    let merchantId: string;

    // Determine merchant ID based on user role
    if (currentUser.role === ROLES.ADMIN) {
      // Admin must provide merchantId
      if (!createDto.merchantId) {
        throw new BadRequestException(
          API_RESPONSE_MESSAGES.OFFER.INVALID_MERCHANT,
        );
      }

      // Verify merchant exists and is a corporate merchant
      const merchant = await this.prisma.merchants.findUnique({
        where: { id: createDto.merchantId },
        include: {
          users: {
            select: {
              role: true,
            },
          },
        },
      });

      if (!merchant) {
        throw new NotFoundException(API_RESPONSE_MESSAGES.MERCHANT.NOT_FOUND);
      }

      if (merchant.users.role !== ROLES.MERCHANT_CORPORATE) {
        throw new BadRequestException(
          API_RESPONSE_MESSAGES.OFFER.INVALID_MERCHANT,
        );
      }

      merchantId = createDto.merchantId;
    } else if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      // Merchant corporate uses their own merchant ID
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }

      // Merchant corporate should not provide merchantId
      if (createDto.merchantId) {
        throw new BadRequestException(
          'Merchant corporate users cannot specify merchantId. Use your own merchant account.',
        );
      }

      merchantId = currentUser.merchant_id;
    } else {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    // Validate date range
    const validFrom = new Date(createDto.validFrom);
    const validUntil = new Date(createDto.validUntil);
    if (validUntil <= validFrom) {
      this.logger.warn(`Invalid date range: From ${validFrom} to ${validUntil}`);
      throw new BadRequestException(
        API_RESPONSE_MESSAGES.OFFER.INVALID_DATE_RANGE,
      );
    }

    // Validate discount value for percentage
    if (
      createDto.discountType === 'percentage' &&
      createDto.discountValue &&
      createDto.discountValue > 100
    ) {
      this.logger.warn(`Invalid discount value: ${createDto.discountValue}`);
      throw new BadRequestException(
        API_RESPONSE_MESSAGES.OFFER.INVALID_DISCOUNT_VALUE,
      );
    }

    // Validate branches if provided
    let targetBranchIds: string[] = [];

    // If branchIds are provided, only target those branches
    if (createDto.branchIds && createDto.branchIds.length > 0) {
      // Validate that these branches belong to the merchant
      const branches = await this.prisma.merchant_branches.findMany({
        where: {
          id: { in: createDto.branchIds },
          merchant_id: merchantId,
          is_active: true, // Should we allow inactive? Probably not for new offers.
        },
      });

      if (branches.length !== createDto.branchIds.length) {
        throw new BadRequestException('One or more invalid branch IDs provided');
      }
      targetBranchIds = branches.map((b) => b.id);
      targetBranchIds = branches.map((b) => b.id);
    } else {
      // If no branches selected (e.g. from UI popup that says "Assign later"),
      // we create the offer as INACTIVE and unassigned.
      // This prevents "Global Conflict" with existing active offers.
      targetBranchIds = [];
    }

    // Check for "One Active Offer" rule - verify branches don't already have active offers
    // REPLACED LOGIC: Instead of throwing error, we will automatically "claim" these branches
    // by removing them from any other offers in the transaction below.
    // This strictly enforces the "One Active Offer Per Branch" rule without admin intervention.

    // Validate schedule fields
    const scheduleType = createDto.scheduleType || 'always';
    if (scheduleType === 'custom') {
      // Validate allowed days
      if (createDto.allowedDays && createDto.allowedDays.length > 0) {
        const invalidDays = createDto.allowedDays.filter(
          (day) => day < 0 || day > 6,
        );
        if (invalidDays.length > 0) {
          throw new BadRequestException(
            'allowedDays must contain values between 0 (Sunday) and 6 (Saturday)',
          );
        }
      }

      // Validate time fields
      if (createDto.startTime && createDto.endTime) {
        const [startHours, startMinutes] = createDto.startTime
          .split(':')
          .map(Number);
        const [endHours, endMinutes] = createDto.endTime.split(':').map(Number);
        const startTotal = startHours * 60 + startMinutes;
        const endTotal = endHours * 60 + endMinutes;

        if (endTotal <= startTotal) {
          throw new BadRequestException('endTime must be after startTime');
        }
      } else if (createDto.startTime || createDto.endTime) {
        throw new BadRequestException(
          'Both startTime and endTime must be provided when scheduleType is custom',
        );
      }
    }

    // Convert time strings to Date objects for database storage
    const convertTimeToDate = (timeString: string | undefined): Date | null => {
      if (!timeString) return null;
      const [hours, minutes] = timeString.split(':').map(Number);
      const date = new Date();
      date.setUTCHours(hours, minutes, 0, 0);
      return date;
    };

    // Create offer
    const offer = await this.prisma.$transaction(async (tx) => {
      const newOffer = await tx.offers.create({
        data: {
          merchant_id: merchantId,
          title: createDto.title,
          description: createDto.description || null,
          image_url: createDto.imageUrl || null,
          discount_type: createDto.discountType,
          discount_value: createDto.discountValue ?? 0,
          min_order_value: createDto.minOrderValue || 0,
          max_discount_amount:
            createDto.discountType === DISCOUNT_TYPE.ITEM
              ? null
              : createDto.maxDiscountAmount || null,
          terms_conditions: createDto.termsConditions || null,
          valid_from: validFrom,
          valid_until: validUntil,
          daily_limit: createDto.dailyLimit || null,
          total_limit: createDto.totalLimit || null,
          current_redemptions: 0,
          // Always create as 'active', even if unassigned.
          // Unassigned offers (no branches) won't cause conflicts.
          // They need to be active to appear in the "Branch Assignment" dropdowns.
          status: 'active',
          created_by: currentUser.id,
          schedule_type: scheduleType,
          allowed_days:
            scheduleType === 'custom' && createDto.allowedDays
              ? createDto.allowedDays
              : [],
          start_time:
            scheduleType === 'custom'
              ? convertTimeToDate(createDto.startTime)
              : null,
          end_time:
            scheduleType === 'custom'
              ? convertTimeToDate(createDto.endTime)
              : null,
          additional_item: createDto.additionalItem || null,
          notes: createDto.notes || null,
        },
      });

      // Assign to target branches (calculated above)
      // Use targetBranchIds which already contains either specific selection or all active branches
      const branchesToAssign = await tx.merchant_branches.findMany({
        where: {
          id: { in: targetBranchIds },
          merchant_id: merchantId,
          is_active: true,
        },
      });

      if (branchesToAssign.length > 0) {
        // Enforce uniqueness: Remove these branches from any other offers first
        // This effectively "steals" the branch for the new offer
        await tx.offer_branches.deleteMany({
          where: {
            branch_id: { in: branchesToAssign.map(b => b.id) },
          },
        });

        await tx.offer_branches.createMany({
          data: branchesToAssign.map((branch) => ({
            offer_id: newOffer.id,
            branch_id: branch.id,
          })),
        });
      }

      return newOffer;
    });

    // Fetch created offer with relations
    const offerWithRelations = await this.prisma.offers.findUnique({
      where: { id: offer.id },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
      },
    });

    return this.formatOfferResponse(offerWithRelations);
  }

  /**
   * Get all offers for a merchant
   * Merchant Corporate only
   */
  async getMerchantOffers(
    currentUser: CurrentUser,
    status?: OfferStatus,
    page: number = 1,
    limit: number = 10,
  ): Promise<{ items: OfferResponse[]; pagination: PaginationMeta }> {
    if (currentUser.role !== ROLES.MERCHANT_CORPORATE) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    if (!currentUser.merchant?.id) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    const merchantId = currentUser.merchant_id;
    const skip = calculateSkip(page, limit);

    const whereClause: Prisma.offersWhereInput = {
      merchant_id: merchantId,
    };

    if (status) {
      whereClause.status = status;
    }

    const [offers, total] = await Promise.all([
      this.prisma.offers.findMany({
        where: whereClause,
        include: {
          offer_branches: {
            include: {
              merchant_branches: {
                select: {
                  id: true,
                  branch_name: true,
                  is_active: true,
                },
              },
            },
          },
        },
        orderBy: {
          created_at: 'desc',
        },
        skip,
        take: limit,
      }),
      this.prisma.offers.count({
        where: whereClause,
      }),
    ]);

    const formattedOffers = offers.map((offer) =>
      this.formatOfferResponse(offer),
    );

    return {
      items: formattedOffers,
      pagination: calculatePaginationMeta(total, page, limit),
    };
  }

  /**
   * Get offer by ID
   * Merchant Corporate only (their own offers)
   */
  async getOfferById(
    id: string,
    currentUser: CurrentUser,
  ): Promise<OfferResponse> {
    const offer = await this.prisma.offers.findUnique({
      where: { id },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Authorization check
    if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
      if (offer.merchant_id !== currentUser.merchant_id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
    } else if (currentUser.role !== ROLES.ADMIN) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    return this.formatOfferResponse(offer);
  }

  /**
   * Update offer
   * Merchant Corporate only (their own offers)
   */
  async updateOffer(
    id: string,
    updateDto: UpdateOfferDto,
    currentUser: CurrentUser,
  ): Promise<OfferResponse> {
    // Check if offer exists
    const offer = await this.prisma.offers.findUnique({
      where: { id },
      include: {
        merchants: true,
      },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Authorization check
    if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
      if (offer.merchant_id !== currentUser.merchant_id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
    } else if (currentUser.role !== ROLES.ADMIN) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    // Validate date range if both dates are provided
    if (updateDto.validFrom && updateDto.validUntil) {
      const validFrom = new Date(updateDto.validFrom);
      const validUntil = new Date(updateDto.validUntil);
      if (validUntil <= validFrom) {
        throw new BadRequestException(
          API_RESPONSE_MESSAGES.OFFER.INVALID_DATE_RANGE,
        );
      }
    } else if (updateDto.validFrom) {
      const validFrom = new Date(updateDto.validFrom);
      const validUntil = new Date(offer.valid_until);
      if (validUntil <= validFrom) {
        throw new BadRequestException(
          API_RESPONSE_MESSAGES.OFFER.INVALID_DATE_RANGE,
        );
      }
    } else if (updateDto.validUntil) {
      const validFrom = new Date(offer.valid_from);
      const validUntil = new Date(updateDto.validUntil);
      if (validUntil <= validFrom) {
        throw new BadRequestException(
          API_RESPONSE_MESSAGES.OFFER.INVALID_DATE_RANGE,
        );
      }
    }

    // Validate discount value for percentage
    if (
      (updateDto.discountType === 'percentage' ||
        offer.discount_type === 'percentage') &&
      updateDto.discountValue
    ) {
      if (updateDto.discountValue > 100) {
        throw new BadRequestException(
          API_RESPONSE_MESSAGES.OFFER.INVALID_DISCOUNT_VALUE,
        );
      }
    }

    // Validate schedule fields if provided
    const offerScheduleType = offer.schedule_type ?? 'always';
    const newScheduleType = updateDto.scheduleType ?? offerScheduleType;

    // If changing to 'custom', validate required fields
    if (newScheduleType === 'custom') {
      // Validate allowed days if provided
      const allowedDays = updateDto.allowedDays ?? offer.allowed_days ?? [];
      if (allowedDays.length > 0) {
        const invalidDays = allowedDays.filter((day) => day < 0 || day > 6);
        if (invalidDays.length > 0) {
          throw new BadRequestException(
            'allowedDays must contain values between 0 (Sunday) and 6 (Saturday)',
          );
        }
      }

      // If changing to custom or updating times, validate
      const isChangingToCustom =
        updateDto.scheduleType === 'custom' && offerScheduleType !== 'custom';
      const isUpdatingTimes =
        updateDto.startTime !== undefined || updateDto.endTime !== undefined;

      if (isChangingToCustom || isUpdatingTimes) {
        const startTime =
          updateDto.startTime ??
          (offer.start_time ? this.formatTimeFromDate(offer.start_time) : null);
        const endTime =
          updateDto.endTime ??
          (offer.end_time ? this.formatTimeFromDate(offer.end_time) : null);

        if (!startTime || !endTime) {
          throw new BadRequestException(
            'Both startTime and endTime must be provided when scheduleType is custom',
          );
        }

        const [startHours, startMinutes] = startTime.split(':').map(Number);
        const [endHours, endMinutes] = endTime.split(':').map(Number);
        const startTotal = startHours * 60 + startMinutes;
        const endTotal = endHours * 60 + endMinutes;

        if (endTotal <= startTotal) {
          throw new BadRequestException('endTime must be after startTime');
        }
      }
    }

    // Convert time strings to Date objects for database storage
    const convertTimeToDate = (timeString: string | undefined): Date | null => {
      if (!timeString) return null;
      const [hours, minutes] = timeString.split(':').map(Number);
      const date = new Date();
      date.setUTCHours(hours, minutes, 0, 0);
      return date;
    };

    // Prepare update data
    const updateData: {
      title?: string;
      description?: string | null;
      image_url?: string | null;
      discount_type?: string;
      discount_value?: number;
      min_order_value?: number;
      max_discount_amount?: number | null;
      terms_conditions?: string | null;
      valid_from?: Date;
      valid_until?: Date;
      daily_limit?: number | null;
      total_limit?: number | null;
      status?: 'active' | 'inactive';
      schedule_type?: string;
      allowed_days?: number[];
      start_time?: Date | null;
      end_time?: Date | null;
    } = {};
    if (updateDto.title !== undefined) {
      updateData.title = updateDto.title;
    }
    if (updateDto.description !== undefined) {
      updateData.description = updateDto.description;
    }
    if (updateDto.imageUrl !== undefined) {
      updateData.image_url = updateDto.imageUrl;
    }
    if (updateDto.discountType !== undefined) {
      updateData.discount_type = updateDto.discountType;
      if (updateDto.discountType === DISCOUNT_TYPE.ITEM) {
        if (updateDto.discountValue === undefined) {
          updateData.discount_value = 0;
        }
        if (updateDto.maxDiscountAmount === undefined) {
          updateData.max_discount_amount = null;
        }
      }
    }
    if (updateDto.discountValue !== undefined) {
      updateData.discount_value = updateDto.discountValue;
    }
    if (updateDto.minOrderValue !== undefined) {
      updateData.min_order_value = updateDto.minOrderValue;
    }
    if (updateDto.maxDiscountAmount !== undefined) {
      updateData.max_discount_amount = updateDto.maxDiscountAmount;
    }
    if (updateDto.termsConditions !== undefined) {
      updateData.terms_conditions = updateDto.termsConditions;
    }
    if (updateDto.validFrom !== undefined) {
      updateData.valid_from = new Date(updateDto.validFrom);
    }
    if (updateDto.validUntil !== undefined) {
      updateData.valid_until = new Date(updateDto.validUntil);
    }
    if (updateDto.dailyLimit !== undefined) {
      updateData.daily_limit = updateDto.dailyLimit;
    }
    if (updateDto.totalLimit !== undefined) {
      updateData.total_limit = updateDto.totalLimit;
    }
    if (updateDto.status !== undefined) {
      updateData.status = updateDto.status;
    }
    if (updateDto.scheduleType !== undefined) {
      updateData.schedule_type = updateDto.scheduleType;
      // If changing to 'always', clear schedule fields
      if (updateDto.scheduleType === 'always') {
        updateData.allowed_days = [];
        updateData.start_time = null;
        updateData.end_time = null;
      }
    }
    if (updateDto.allowedDays !== undefined) {
      updateData.allowed_days = updateDto.allowedDays;
    }
    if (updateDto.startTime !== undefined) {
      updateData.start_time = convertTimeToDate(updateDto.startTime);
    }
    if (updateDto.endTime !== undefined) {
      updateData.end_time = convertTimeToDate(updateDto.endTime);
    }
    if (updateDto.additionalItem !== undefined) {
      (updateData as any).additional_item = updateDto.additionalItem;
    }
    if (updateDto.notes !== undefined) {
      (updateData as any).notes = updateDto.notes;
    }

    // Update offer
    const updatedOffer = await this.prisma.offers.update({
      where: { id },
      data: updateData,
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
      },
    });

    return this.formatOfferResponse(updatedOffer);
  }

  /**
   * Toggle offer status (active/inactive)
   * Merchant Corporate only (their own offers)
   */
  async toggleOfferStatus(
    id: string,
    currentUser: CurrentUser,
  ): Promise<OfferResponse> {
    // Check if offer exists
    const offer = await this.prisma.offers.findUnique({
      where: { id },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Authorization check
    if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
      if (offer.merchant_id !== currentUser.merchant_id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
    } else if (currentUser.role !== ROLES.ADMIN) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    // Toggle status
    const newStatus = offer.status === 'active' ? 'inactive' : 'active';

    // Update offer status
    const updatedOffer = await this.prisma.offers.update({
      where: { id },
      data: { status: newStatus },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
    });

    return this.formatOfferResponse(updatedOffer);
  }

  /**
   * Delete offer
   * Merchant Corporate only (their own offers)
   */
  async deleteOffer(id: string, currentUser: CurrentUser): Promise<null> {
    // Check if offer exists
    const offer = await this.prisma.offers.findUnique({
      where: { id },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Authorization check
    if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
      if (offer.merchant_id !== currentUser.merchant_id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
    } else if (currentUser.role !== ROLES.ADMIN) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    // Delete offer (cascade will handle related records)
    try {
      await this.prisma.offers.delete({
        where: { id },
      });
    } catch (error) {
      if (
        error instanceof Prisma.PrismaClientKnownRequestError &&
        error.code === 'P2003'
      ) {
        throw new BadRequestException(
          'Cannot delete this offer because it has already been redeemed. Please deactivate it instead.',
        );
      }
      throw error;
    }

    return null;
  }

  /**
   * Assign offer to branches
   * Merchant Corporate only
   */
  async assignBranchesToOffer(
    id: string,
    assignDto: AssignBranchesDto,
    currentUser: CurrentUser,
  ): Promise<OfferResponse> {
    // Check if offer exists
    const offer = await this.prisma.offers.findUnique({
      where: { id },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Authorization check
    if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
      if (offer.merchant_id !== currentUser.merchant_id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
    } else if (currentUser.role !== ROLES.ADMIN) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    // Validate branches belong to the merchant
    const branches = await this.prisma.merchant_branches.findMany({
      where: {
        id: { in: assignDto.branchIds },
        merchant_id: offer.merchant_id,
      },
    });

    if (branches.length !== assignDto.branchIds.length) {
      throw new BadRequestException(
        API_RESPONSE_MESSAGES.OFFER.BRANCH_NOT_BELONGS_TO_MERCHANT,
      );
    }

    // Assign branches (upsert to handle duplicates)
    await this.prisma.$transaction(async (tx) => {
      // Remove existing assignments for these branches completely (from ANY offer)
      // This enforces "One Active Offer Per Branch"
      await tx.offer_branches.deleteMany({
        where: {
          // Removed offer_id constraint to delete assignments from any offer
          branch_id: { in: assignDto.branchIds },
        },
      });

      // Create new assignments
      await tx.offer_branches.createMany({
        data: assignDto.branchIds.map((branchId) => ({
          offer_id: id,
          branch_id: branchId,
        })),
      });
    });

    // Fetch updated offer
    const updatedOffer = await this.prisma.offers.findUnique({
      where: { id },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
      },
    });

    return this.formatOfferResponse(updatedOffer!);
  }

  /**
   * Remove offer from branches
   * Merchant Corporate only
   */
  async removeBranchesFromOffer(
    id: string,
    assignDto: AssignBranchesDto,
    currentUser: CurrentUser,
  ): Promise<OfferResponse> {
    // Check if offer exists
    const offer = await this.prisma.offers.findUnique({
      where: { id },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Authorization check
    if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
      if (offer.merchant_id !== currentUser.merchant_id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
    } else if (currentUser.role !== ROLES.ADMIN) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    // Remove branch assignments
    await this.prisma.offer_branches.deleteMany({
      where: {
        offer_id: id,
        branch_id: { in: assignDto.branchIds },
      },
    });

    // Fetch updated offer
    const updatedOffer = await this.prisma.offers.findUnique({
      where: { id },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
      },
    });

    return this.formatOfferResponse(updatedOffer!);
  }

  /**
   * Get offer analytics
   * Merchant Corporate only
   */
  async getOfferAnalytics(
    id: string,
    currentUser: CurrentUser,
  ): Promise<OfferAnalyticsResponse> {
    // Check if offer exists
    const offer = await this.prisma.offers.findUnique({
      where: { id },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Authorization check
    if (currentUser.role === ROLES.MERCHANT_CORPORATE) {
      if (!currentUser.merchant?.id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
      if (offer.merchant_id !== currentUser.merchant_id) {
        throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
      }
    } else if (currentUser.role !== ROLES.ADMIN) {
      throw new ForbiddenException(API_RESPONSE_MESSAGES.OFFER.ACCESS_DENIED);
    }

    // Get redemptions by branch
    const redemptionsByBranch = await this.prisma.redemptions.groupBy({
      by: ['branch_id'],
      where: {
        offer_id: id,
      },
      _count: {
        id: true,
      },
    });

    // Get branch details
    const branchIds = redemptionsByBranch.map((r) => r.branch_id);
    const branches = await this.prisma.merchant_branches.findMany({
      where: {
        id: { in: branchIds },
      },
      select: {
        id: true,
        branch_name: true,
      },
    });

    const branchMap = new Map(branches.map((b) => [b.id, b.branch_name]));

    // Get redemptions by date (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const redemptionsByDateRaw = await this.prisma.redemptions.groupBy({
      by: ['created_at'],
      where: {
        offer_id: id,
        created_at: {
          gte: thirtyDaysAgo,
        },
      },
      _count: {
        id: true,
      },
    });

    // Group by date (day)
    const dateMap = new Map<string, number>();
    redemptionsByDateRaw.forEach((r) => {
      const date = new Date(r.created_at!).toISOString().split('T')[0];
      dateMap.set(date, (dateMap.get(date) || 0) + r._count.id);
    });

    const redemptionsByDate = Array.from(dateMap.entries())
      .map(([date, count]) => ({ date, count }))
      .sort((a, b) => a.date.localeCompare(b.date));

    const totalRedemptions = offer.current_redemptions || 0;
    const remainingRedemptions = offer.total_limit
      ? offer.total_limit - totalRedemptions
      : null;

    return {
      totalRedemptions,
      currentRedemptions: totalRedemptions,
      remainingRedemptions,
      redemptionsByBranch: redemptionsByBranch.map((r) => ({
        branchId: r.branch_id,
        branchName: branchMap.get(r.branch_id) || 'Unknown',
        redemptionCount: r._count.id,
      })),
      redemptionsByDate,
    };
  }

  /**
   * Get all offers (Admin)
   * Admin only
   */
  async getAllOffers(
    status?: OfferStatus,
    merchantId?: string,
    page: number = 1,
    limit: number = 10,
  ): Promise<{ items: OfferResponse[]; pagination: PaginationMeta }> {
    const skip = calculateSkip(page, limit);

    const whereClause: Prisma.offersWhereInput = {};
    if (status) {
      whereClause.status = status;
    }
    if (merchantId) {
      whereClause.merchant_id = merchantId;
    }

    const [offers, total] = await Promise.all([
      this.prisma.offers.findMany({
        where: whereClause,
        include: {
          offer_branches: {
            include: {
              merchant_branches: {
                select: {
                  id: true,
                  branch_name: true,
                  is_active: true,
                },
              },
            },
          },
          merchants: {
            select: {
              id: true,
              business_name: true,
              logo_path: true,
              category: true,
              banner_url: true,
            },
          },
        },
        orderBy: {
          created_at: 'desc',
        },
        skip,
        take: limit,
      }),
      this.prisma.offers.count({
        where: whereClause,
      }),
    ]);

    const formattedOffers = offers.map((offer) =>
      this.formatOfferResponse(offer),
    );

    return {
      items: formattedOffers,
      pagination: calculatePaginationMeta(total, page, limit),
    };
  }

  /**
   * Get offer by ID (Admin)
   * Admin only
   */
  async getOfferByIdAdmin(id: string): Promise<OfferResponse> {
    const offer = await this.prisma.offers.findUnique({
      where: { id },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    return this.formatOfferResponse(offer);
  }

  /**
   * Approve or reject offer (Admin)
   * Admin only
   */
  async approveRejectOffer(
    id: string,
    approveRejectDto: ApproveRejectOfferDto,
  ): Promise<OfferResponse> {
    const offer = await this.prisma.offers.findUnique({
      where: { id },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Update offer status
    const status =
      approveRejectDto.action === 'approve' ? 'active' : 'inactive';

    const updatedOffer = await this.prisma.offers.update({
      where: { id },
      data: { status },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
    });

    return this.formatOfferResponse(updatedOffer);
  }

  /**
   * Delete offer (Admin)
   * Admin only
   */
  async deleteOfferAdmin(id: string): Promise<null> {
    const offer = await this.prisma.offers.findUnique({
      where: { id },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Delete offer (cascade will handle related records)
    await this.prisma.offers.delete({
      where: { id },
    });

    return null;
  }

  /**
   * Get active offers for students
   * Student only
   */
  async getActiveOffersForStudents(
    category?: string,
    latitude?: number,
    longitude?: number,
    radius: number = 10,
    sort?: 'popularity' | 'proximity' | 'newest',
    page: number = 1,
    limit: number = 10,
  ): Promise<{
    items: OfferResponseWithDistance[];
    pagination: PaginationMeta;
  }> {
    const skip = calculateSkip(page, limit);
    const now = new Date();

    // Build where clause for active offers
    const whereClause: Prisma.offersWhereInput = {
      status: 'active',
      valid_from: { lte: now },
      valid_until: { gte: now },
    };

    // Filter by merchant category if provided
    if (category) {
      whereClause.merchants = {
        category: category,
      };
    }

    // Get all active offers with merchant and branch info
    const offers = await this.prisma.offers.findMany({
      where: whereClause,
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                latitude: true,
                longitude: true,
                address: true,
                city: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
    });

    // Format offers and calculate distances if coordinates provided
    let formattedOffers: OfferResponseWithDistance[] = offers.map((offer) => {
      const formatted = this.formatOfferResponse(offer);

      // Calculate minimum distance to any branch if coordinates provided
      if (latitude !== undefined && longitude !== undefined) {
        const distances = offer.offer_branches
          .filter(
            (ob) =>
              ob.merchant_branches.latitude && ob.merchant_branches.longitude,
          )
          .map((ob) => {
            const branchLat = Number(ob.merchant_branches.latitude);
            const branchLng = Number(ob.merchant_branches.longitude);
            return this.calculateDistance(
              latitude,
              longitude,
              branchLat,
              branchLng,
            );
          });

        const minDistance =
          distances.length > 0 ? Math.min(...distances) : undefined;
        return {
          ...formatted,
          distance: minDistance,
        } as OfferResponseWithDistance;
      }

      return formatted as OfferResponseWithDistance;
    });

    // Filter by radius if coordinates provided
    if (latitude !== undefined && longitude !== undefined) {
      formattedOffers = formattedOffers.filter(
        (offer) => offer.distance !== undefined && offer.distance <= radius,
      );
    }

    // Sort offers
    if (sort === 'popularity') {
      formattedOffers.sort(
        (a, b) => b.currentRedemptions - a.currentRedemptions,
      );
    } else if (
      sort === 'proximity' &&
      latitude !== undefined &&
      longitude !== undefined
    ) {
      formattedOffers.sort((a, b) => {
        const distA = a.distance ?? Infinity;
        const distB = b.distance ?? Infinity;
        return distA - distB;
      });
    } else if (sort === 'newest') {
      formattedOffers.sort((a, b) => {
        const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
        const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
        return dateB - dateA;
      });
    }

    // Apply pagination
    const total = formattedOffers.length;
    const paginatedOffers = formattedOffers.slice(skip, skip + limit);

    return {
      items: paginatedOffers,
      pagination: calculatePaginationMeta(total, page, limit),
    };
  }

  /**
   * Get offer details for students
   * Student only
   */
  async getOfferDetailsForStudents(id: string): Promise<OfferDetailsResponse> {
    const now = new Date();

    const offer = await this.prisma.offers.findUnique({
      where: { id },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                address: true,
                city: true,
                latitude: true,
                longitude: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
    });

    if (!offer) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    // Check if offer is active and valid
    if (
      offer.status !== 'active' ||
      offer.valid_from > now ||
      offer.valid_until < now
    ) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.OFFER.NOT_FOUND);
    }

    const formatted = this.formatOfferResponse(offer);

    // Format branches with full details
    const branches = offer.offer_branches.map((ob) => ({
      branchId: ob.merchant_branches.id,
      branchName: ob.merchant_branches.branch_name,
      address: ob.merchant_branches.address,
      city: ob.merchant_branches.city,
      latitude: ob.merchant_branches.latitude
        ? Number(ob.merchant_branches.latitude)
        : null,
      longitude: ob.merchant_branches.longitude
        ? Number(ob.merchant_branches.longitude)
        : null,
      isActive: ob.merchant_branches.is_active ?? true,
    }));

    return {
      ...formatted,
      branches,
    };
  }

  /**
   * Get offers by merchant for students
   * Student only
   */
  async getOffersByMerchantForStudents(
    merchantId: string,
  ): Promise<OfferResponse[]> {
    const now = new Date();

    // Verify merchant exists
    const merchant = await this.prisma.merchants.findUnique({
      where: { id: merchantId },
    });

    if (!merchant) {
      throw new NotFoundException(API_RESPONSE_MESSAGES.MERCHANT.NOT_FOUND);
    }

    // Get active offers for this merchant
    const offers = await this.prisma.offers.findMany({
      where: {
        merchant_id: merchantId,
        status: 'active',
        valid_from: { lte: now },
        valid_until: { gte: now },
      },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
      orderBy: {
        created_at: 'desc',
      },
    });

    const formattedOffers = offers.map((offer) =>
      this.formatOfferResponse(offer),
    );

    return formattedOffers;
  }

  /**
   * Calculate distance between two coordinates using Haversine formula
   * Returns distance in kilometers
   */
  private calculateDistance(
    lat1: number,
    lon1: number,
    lat2: number,
    lon2: number,
  ): number {
    const R = 6371; // Earth's radius in kilometers
    const dLat = this.toRadians(lat2 - lat1);
    const dLon = this.toRadians(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRadians(lat1)) *
      Math.cos(this.toRadians(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  /**
   * Convert degrees to radians
   */
  private toRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
  }

  /**
   * Format time from Date to HH:mm string
   */
  private formatTimeFromDate(time: Date | null | undefined): string | null {
    if (!time) return null;
    const date = new Date(time);
    const hours = date.getUTCHours().toString().padStart(2, '0');
    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  /**
   * Format offer response
   */
  private formatOfferResponse(offer: any): OfferResponse {
    // Format time fields from DateTime to HH:mm string
    const formatTime = (time: Date | null | undefined): string | null => {
      if (!time) return null;
      const date = new Date(time);
      const hours = date.getUTCHours().toString().padStart(2, '0');
      const minutes = date.getUTCMinutes().toString().padStart(2, '0');
      return `${hours}:${minutes}`;
    };

    return {
      id: offer.id,
      merchantId: offer.merchant_id,
      title: offer.title,
      description: offer.description,
      imageUrl: offer.image_url,
      discountType: offer.discount_type,
      discountValue: Number(offer.discount_value),
      minOrderValue: offer.min_order_value
        ? Number(offer.min_order_value)
        : null,
      maxDiscountAmount: offer.max_discount_amount
        ? Number(offer.max_discount_amount)
        : null,
      termsConditions: offer.terms_conditions,
      validFrom: offer.valid_from,
      validUntil: offer.valid_until,
      dailyLimit: offer.daily_limit,
      totalLimit: offer.total_limit,
      currentRedemptions: offer.current_redemptions || 0,
      status: offer.status,
      createdBy: offer.created_by,
      createdAt: offer.created_at,
      updatedAt: offer.updated_at,
      scheduleType: offer.schedule_type || 'always',
      allowedDays: offer.allowed_days || [],
      startTime: offer.start_time
        ? this.formatTimeFromDate(offer.start_time)
        : null,
      endTime: offer.end_time ? this.formatTimeFromDate(offer.end_time) : null,
      branches: offer.offer_branches
        ? offer.offer_branches.map((ob: any) => ({
          branchId: ob.merchant_branches.id,
          branchName: ob.merchant_branches.branch_name,
          isActive: ob.is_active,
        }))
        : undefined,
      merchant: offer.merchants
        ? {
          id: offer.merchants.id,
          businessName: offer.merchants.business_name,
          logoPath: offer.merchants.logo_path,
          category: offer.merchants.category,
          bannerUrl: offer.merchants.banner_url,
        }
        : undefined,
      featuredOrder: offer.featured_order,
      additionalItem: offer.additional_item,
      notes: offer.notes,
    };
  }

  /**
   * Get all active featured offers
   * Public / Student
   * Returns top 6 featured offers sorted by order
   */
  async getFeaturedOffers(): Promise<OfferResponse[]> {
    const offers = await this.prisma.offers.findMany({
      where: {
        status: 'active',
        featured_order: { not: null },
        valid_from: { lte: new Date() },
        valid_until: { gte: new Date() },
      },
      include: {
        offer_branches: {
          include: {
            merchant_branches: {
              select: {
                id: true,
                branch_name: true,
                is_active: true,
              },
            },
          },
        },
        merchants: {
          select: {
            id: true,
            business_name: true,
            logo_path: true,
            category: true,
            banner_url: true,
          },
        },
      },
      orderBy: {
        featured_order: 'asc',
      },
    });

    return offers.map((offer) => this.formatOfferResponse(offer));
  }

  /**
   * Set featured offers (top 6)
   * Admin only
   */
  async setFeaturedOffers(
    dto: SetFeaturedOffersDto,
  ): Promise<{ message: string }> {
    // Validate that all offer IDs exist and are active
    const offerIds = dto.offers.map((o) => o.offerId);
    const existingOffers = await this.prisma.offers.findMany({
      where: {
        id: { in: offerIds },
        status: 'active',
      },
      select: { id: true },
    });

    if (existingOffers.length !== offerIds.length) {
      throw new BadRequestException(
        'One or more offers not found or are not active',
      );
    }

    // Validate that orders are unique and within 1-6 range
    const orders = dto.offers.map((o) => o.order);
    const uniqueOrders = new Set(orders);
    if (uniqueOrders.size !== orders.length) {
      throw new BadRequestException('Featured orders must be unique (1-6)');
    }

    // Use transaction to update all offers
    await this.prisma.$transaction(async (tx) => {
      // First, clear all existing featured orders
      await tx.offers.updateMany({
        where: {
          featured_order: { not: null },
        },
        data: {
          featured_order: null,
        },
      });

      // Then, set the new featured orders
      for (const offer of dto.offers) {
        await tx.offers.update({
          where: { id: offer.offerId },
          data: { featured_order: offer.order },
        });
      }
    });

    return { message: 'Featured offers updated successfully' };
  }
}
